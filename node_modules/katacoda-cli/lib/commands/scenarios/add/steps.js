"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const inquirer = require('inquirer');
const fs = require("fs");
const validation_service_1 = require("../../../helpers/validation-service");
const file_utils_1 = require("../../../helpers/file-utils");
class StepCreate extends command_1.Command {
    getScenarioSteps(scenarioData) {
        const scenarioDetails = scenarioData;
        const steps = scenarioDetails.details.steps;
        return steps;
    }
    generateFileNames(start, stop) {
        const fileNames = [];
        for (let i = start; i <= stop; i++) {
            fileNames.push(`step${i}`);
        }
        return fileNames;
    }
    updateScenarioIndexFile(scenarioPath, content, steps) {
        const newContent = content;
        const stepObjects = file_utils_1.generateStepsFormat(steps);
        const updatedSteps = newContent.details.steps.concat(stepObjects);
        newContent.details.steps = updatedSteps;
        const data = JSON.stringify(newContent, null, 2);
        fs.writeFileSync(`${scenarioPath}/index.json`, data, 'utf8');
    }
    async getStepDetails(scenarioPath, steps) {
        const prompt = [];
        if (!scenarioPath) {
            prompt.push({
                name: 'scenarioPath',
                message: 'Enter the path to the scenario',
                default: process.cwd(),
                validate: validation_service_1.validateScenario
            });
        }
        if (!steps) {
            prompt.push({
                name: 'steps',
                message: 'Number of steps being added',
                validate: validation_service_1.validateNumber
            });
        }
        const response = await inquirer.prompt(prompt);
        scenarioPath && (response.scenarioPath = scenarioPath);
        steps && (response.steps = steps);
        return response;
    }
    async run() {
        let steps, scenarioPath;
        try {
            const { flags } = this.parse(StepCreate);
            if (flags.scenariopath) {
                const isScenarioValid = await validation_service_1.validateScenario(flags.scenariopath);
                if (isScenarioValid !== true) {
                    throw isScenarioValid;
                }
                scenarioPath = flags.scenariopath;
            }
            if (flags.steps) {
                const isStepValid = validation_service_1.validateNumber(flags.steps);
                if (isStepValid !== true) {
                    throw isStepValid;
                }
                ({ steps } = flags);
            }
            const stepDetails = await this.getStepDetails(scenarioPath, steps);
            const scenarioData = file_utils_1.getFileContents(`${stepDetails.scenarioPath}/index.json`);
            const existingSteps = this.getScenarioSteps(scenarioData);
            const startIndex = existingSteps.length + 1;
            const stopIndex = existingSteps.length + Number(stepDetails.steps);
            const filenames = this.generateFileNames(startIndex, stopIndex);
            file_utils_1.createMarkdownFiles(stepDetails.scenarioPath, filenames);
            this.updateScenarioIndexFile(stepDetails.scenarioPath, scenarioData, filenames);
            const splitScenarioPath = stepDetails.scenarioPath.split('/');
            const scenarioName = splitScenarioPath[splitScenarioPath.length - 1];
            this.log(`${stepDetails.steps} ${stepDetails.steps === 1 ? 'step' : 'steps'} added to ${scenarioName}`);
        }
        catch (err) {
            return this.error(`Error: ${err.toString()}`);
        }
    }
}
StepCreate.description = 'Add steps to scenario';
StepCreate.flags = {
    scenariopath: command_1.flags.string({ char: 'p', description: 'path to scenario' }),
    steps: command_1.flags.integer({ char: 's', description: 'Number of steps' })
};
exports.default = StepCreate;
