"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const inquirer = require("inquirer");
const validation_service_1 = require("../../../helpers/validation-service");
const file_utils_1 = require("../../../helpers/file-utils");
const fs = require("fs-extra");
class AddAssets extends command_1.Command {
    async getAssetDetails() {
        const responses = inquirer.prompt([
            {
                name: 'scenarioPath',
                message: 'Enter the path to the scenario you want to add an asset to',
                default: process.cwd(),
                validate: validation_service_1.validateScenario
            },
            {
                name: 'asset',
                message: 'Enter the path to the file you will like to add as an asset',
                validate: validation_service_1.validateAsset
            },
            {
                name: 'target',
                message: 'Where should it be stored?'
            },
            {
                name: 'executable',
                message: 'Should this file be executable(is it a script?)',
                type: 'confirm'
            }
        ]);
        return responses;
    }
    async getOverwriteResponse() {
        return inquirer.prompt([
            {
                name: 'answer',
                message: 'This file already exists and will be overwrriten, do you want to continue?',
                type: 'confirm'
            }
        ]);
    }
    updateScenarioDetails(scenarioPath, filename, target, executable) {
        const scenarioDetails = file_utils_1.getFileContents(`${scenarioPath}/index.json`);
        const assets = scenarioDetails.details.assets
            ? Object.assign({}, scenarioDetails.details.assets) : {};
        assets.host01 = assets.host01 || [];
        assets.host01 = assets.host01.filter((asset) => asset.file !== filename);
        const newAsset = { file: filename, target };
        if (executable) {
            newAsset.chmod = '+x';
        }
        assets.host01.push(newAsset);
        scenarioDetails.details.assets = assets;
        fs.writeJsonSync(`${scenarioPath}/index.json`, scenarioDetails, {
            spaces: 2
        });
    }
    async run() {
        try {
            const responses = await this.getAssetDetails();
            const filename = file_utils_1.getFilenameFromPath(responses.asset);
            const fileExistInScenario = fs.existsSync(`${responses.scenarioPath}/assets/${filename}`);
            if (fileExistInScenario) {
                const overwriteResponse = await this.getOverwriteResponse();
                if (!overwriteResponse.answer) {
                    return this.log('Operation Canceled');
                }
            }
            this.updateScenarioDetails(responses.scenarioPath, filename, responses.target, responses.executable);
            fs.ensureDirSync(`${responses.scenarioPath}/assets`);
            fs.copySync(responses.asset, `${responses.scenarioPath}/assets/${filename}`);
            this.log('Asset has been added to scenario');
        }
        catch (err) {
            return this.error(`Error: ${err.toString()}`);
        }
    }
}
AddAssets.description = 'Add assets to scenario';
AddAssets.flags = {
    asset: command_1.flags.string({ char: 'a', description: 'path to asset' }),
    target: command_1.flags.string({
        char: 't',
        description: 'directory the file should be uploaded to ',
        dependsOn: ['asset']
    })
};
exports.default = AddAssets;
