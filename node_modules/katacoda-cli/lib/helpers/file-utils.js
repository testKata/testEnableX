"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const os = require("os");
const path = require('path');
function createMarkdownFiles(directory, fileNames) {
    fileNames.forEach((name) => fs.openSync(`${directory}/${name}.md`, 'w'));
    let steps = [].concat(...fileNames);
    return steps;
}
exports.createMarkdownFiles = createMarkdownFiles;
function generateStepsFormat(steps) {
    return steps.map((name) => ({
        title: name.replace('step', 'Step '),
        text: `${name}.md`
    }));
}
exports.generateStepsFormat = generateStepsFormat;
function validateJSON(path) {
    let content = fs.readFileSync(path);
    var isValidJson = false;
    try {
        var o = JSON.parse(content);
        if (o && typeof o === "object") {
            isValidJson = true;
            return isValidJson;
        }
    }
    catch (e) {
        return e;
    }
}
exports.validateJSON = validateJSON;
function getFileContents(path) {
    let content = fs.readFileSync(path);
    content = JSON.parse(content);
    return content;
}
exports.getFileContents = getFileContents;
function getScenarioIndex(scenarioPath) {
    const indexFilePath = `${scenarioPath}/index.json`;
    let content = fs.readFileSync(indexFilePath);
    content = JSON.parse(content);
    return content;
}
exports.getScenarioIndex = getScenarioIndex;
function getScenarioSteps(scenarioData) {
    const scenarioDetails = scenarioData;
    const steps = scenarioDetails.details.steps;
    return steps;
}
exports.getScenarioSteps = getScenarioSteps;
function getScenarioStepTitles(scenarioPath) {
    const scenarioDetails = getScenarioIndex(scenarioPath);
    const scenarioSteps = getScenarioSteps(scenarioDetails);
    return scenarioSteps.map(step => step.title);
}
exports.getScenarioStepTitles = getScenarioStepTitles;
function reIndexStepFiles(filepath) {
    const files = fs.readdirSync(filepath);
    const stepFiles = files.filter(file => file !== 'intro.md' && file !== 'finish.md' && file !== 'index.json');
    const shouldIndex = stepFiles.every(file => /step\d+.md$/.test(file));
    if (!shouldIndex) {
        return false;
    }
    stepFiles.sort((a, b) => extractStepNumber(a) - extractStepNumber(b));
    return stepFiles.map((file, index) => {
        const oldPath = `${filepath}/${file}`;
        const newPath = `${filepath}/step${index + 1}.md`;
        if (oldPath !== newPath) {
            fs.renameSync(oldPath, newPath);
        }
    });
}
exports.reIndexStepFiles = reIndexStepFiles;
function reIndexScenarioJsonSteps(filepath) {
    const scenarioDetails = getScenarioIndex(filepath);
    const steps = getScenarioSteps(scenarioDetails);
    const newSteps = steps.map((step, index) => {
        return {
            title: `Step ${index + 1}`,
            text: `step${index + 1}.md`
        };
    });
    scenarioDetails.details.steps = newSteps;
    const data = JSON.stringify(scenarioDetails, null, 2);
    fs.writeFileSync(`${filepath}/index.json`, data, 'utf8');
}
exports.reIndexScenarioJsonSteps = reIndexScenarioJsonSteps;
function extractStepNumber(step) {
    return Number(step.substring(4, step.length - 3));
}
function getFilenameFromPath(path) {
    const splitPath = path.split('/');
    return splitPath[splitPath.length - 1];
}
exports.getFilenameFromPath = getFilenameFromPath;
function generateFileNames(count) {
    const fileNames = ['intro', 'finish'];
    for (let i = 1; i <= count; i++) {
        fileNames.push(`step${i}`);
    }
    return fileNames;
}
exports.generateFileNames = generateFileNames;
function getDirectories(path) {
    let directoriesToExclude = ['.git', '.vscode', 'assets', 'training'];
    let directories = fs.readdirSync(path).filter(function (file) {
        return fs.statSync(path + '/' + file).isDirectory();
    });
    directoriesToExclude.forEach((directoryToExclude) => {
        var index = directories.indexOf(directoryToExclude);
        if (index > -1) {
            directories.splice(index, 1);
        }
    });
    return directories;
}
exports.getDirectories = getDirectories;
function listFiles(base, pattern, exclusionPatterns, files, result) {
    files = files || fs.readdirSync(base);
    result = result || [];
    files.forEach(function (file) {
        var newbase = path.join(base, file);
        if (fs.statSync(newbase).isDirectory()) {
            result = listFiles(newbase, pattern, exclusionPatterns, fs.readdirSync(newbase), result);
        }
        else {
            var shouldBeIncluded = true;
            if (exclusionPatterns) {
                for (var i = 0; i < exclusionPatterns.length; i++) {
                    var exclusion = exclusionPatterns[i];
                    shouldBeIncluded = !file.includes(exclusion) && !base.includes(exclusion);
                }
            }
            if (file.endsWith(pattern) && shouldBeIncluded) {
                result.push(newbase);
            }
        }
    });
    return result;
}
exports.listFiles = listFiles;
function getListScenariosDefinitions(repoPath) {
    var directories = getDirectories(repoPath);
    var scenarios = [];
    directories.forEach((directory) => {
        var existIndexJSON = fs.existsSync(repoPath + '/' + directory + '/index.json');
        if (existIndexJSON) {
            scenarios.push(directory);
        }
    });
    return scenarios;
}
exports.getListScenariosDefinitions = getListScenariosDefinitions;
function expandPath(path) {
    return path.replace("~", os.homedir);
}
exports.expandPath = expandPath;
