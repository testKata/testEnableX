"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Joi = require('@hapi/joi');
const chalk = require('chalk');
const _ = require('underscore');
const fs = require("fs");
const path = require("path");
const file_utils_1 = require("../helpers/file-utils");
const constants_1 = require("./constants");
const images_1 = require("../fetchers/images");
const courses_1 = require("../fetchers/courses");
const acceptableLayouts = Object.values(constants_1.defaultLayouts);
const file_utils_2 = require("./file-utils");
class ScenarioValidation {
    constructor(isValid, validationMessage) {
        this.isValid = isValid;
        this.validationMessage = validationMessage;
    }
}
exports.ScenarioValidation = ScenarioValidation;
class CompleteValidation {
    constructor() {
        this.hasErrors = false;
        this.validations = new Array();
    }
    addValidation(scenarioValidation) {
        this.validations.push(scenarioValidation);
        if (scenarioValidation.isValid === false) {
            this.hasErrors = true;
        }
    }
}
exports.CompleteValidation = CompleteValidation;
function onValidation(err) {
    return err ? err.message : true;
}
function validateInput(input) {
    const schema = Joi.string()
        .required()
        .max(100);
    return Joi.validate(input.trim(), schema, onValidation);
}
async function validateIndexJson(scenarioPath) {
    let path = `${scenarioPath}/index.json`;
    if (!fs.existsSync(`${scenarioPath}/index.json`)) {
        return 'Validation Error: Scenario has no index.json file.';
    }
    var isValidJson = file_utils_1.validateJSON(path);
    if (isValidJson != true) {
        return 'Validation Error: index.json is an invalid JSON. Cause '.concat(isValidJson);
    }
    const index = file_utils_1.getFileContents(`${scenarioPath}/index.json`);
    if (!Object.keys(index).length) {
        return 'Validation Error: index.json is empty.';
    }
    if (!index.title) {
        return 'Validation Error: Scenario has no title';
    }
    if (!index.details || !index.details.steps || !index.details.steps.length) {
        return 'Validation Error: Scenario has no steps';
    }
    if (!index.environment || !index.environment.uilayout) {
        return 'Validation Error: Scenario has no layout specified';
    }
    if (!acceptableLayouts.includes(index.environment.uilayout)) {
        return 'Validation Error: Layout specified in the index.json is not part of the acceptable layouts as specified here: https://katacoda.com/docs/scenarios/layouts';
    }
    if (!index.backend || !index.backend.imageid) {
        return 'Validation Error: Scenario has no environment image';
    }
    let isValid = await validateExistingImage(index.backend.imageid);
    if (isValid !== true) {
        return isValid;
    }
    var missingStepFiles = validateMissingStepFiles();
    if (missingStepFiles.length > 0) {
        return 'Validation Error: There are missing scenario files ' + missingStepFiles;
    }
    let missingAssetFiles = validateMissingAssetFiles();
    if (missingAssetFiles.length > 0) {
        return 'Validation Error: There are missing asset files ' + missingAssetFiles;
    }
    return true;
    function validateMissingAssetFiles() {
        var missingFiles = [];
        let specifiedAssets = index.details.assets ? index.details.assets.host01 : [];
        if (specifiedAssets) {
            specifiedAssets = specifiedAssets.map((asset) => asset.file);
            let actualAssets;
            if (fs.existsSync(`${scenarioPath}/assets`)) {
                actualAssets = fs.readdirSync(`${scenarioPath}/assets`);
            }
            else {
                actualAssets = [];
            }
            for (let i = 0; i < specifiedAssets.length; i++) {
                var asset = specifiedAssets[i];
                if (!actualAssets.includes(asset)) {
                    if (asset !== '*') {
                        missingFiles.push(asset);
                    }
                }
            }
        }
        return missingFiles;
    }
    function validateMissingStepFiles() {
        var missingFiles = [];
        let specifiedSteps = index.details.steps || [];
        specifiedSteps = specifiedSteps.map((step) => (step.text));
        let specifiedCodeSteps = index.details.steps;
        specifiedCodeSteps = specifiedCodeSteps.map((step) => (step.code));
        specifiedCodeSteps = _.compact(specifiedCodeSteps);
        specifiedSteps = specifiedSteps.concat(specifiedCodeSteps);
        let actualSteps = fs.readdirSync(scenarioPath);
        actualSteps = actualSteps.filter(file => file !== 'intro.md' &&
            file !== 'finish.md' &&
            file !== 'index.json' &&
            file !== 'assets');
        for (let i = 0; i < specifiedSteps.length; i++) {
            var step = specifiedSteps[i];
            if (!actualSteps.includes(step)) {
                missingFiles.push(step);
            }
        }
        return missingFiles;
    }
}
function validateTitle(title) {
    return validateInput(title);
}
exports.validateTitle = validateTitle;
function validateDescription(description) {
    return description ? validateInput(description) : true;
}
exports.validateDescription = validateDescription;
async function validateExistingImage(imageid) {
    let isValid = await images_1.validateImage(imageid);
    if (isValid == false) {
        return 'Validation Error: Image specified in the index.json is not part of the acceptable environment images as specified here: https://katacoda.com/docs/scenarios/environments';
    }
    else {
        return true;
    }
}
exports.validateExistingImage = validateExistingImage;
function validateFriendlyUrl(url) {
    url = url.trim();
    const isValidUrl = validateInput(url) === true;
    const errorMessage = `ValidationError: ${url} exists. Please enter a different name.`;
    if (isValidUrl) {
        return fs.existsSync(url) ? errorMessage : true;
    }
    else {
        return validateInput(url);
    }
}
exports.validateFriendlyUrl = validateFriendlyUrl;
function validateNumber(number) {
    const schema = Joi.number().required();
    return Joi.validate(number, schema, onValidation);
}
exports.validateNumber = validateNumber;
function getFriendlyUrlFromPath(path) {
    const splitPath = path.split('/');
    const directory = splitPath[splitPath.length - 1];
    return directory;
}
exports.getFriendlyUrlFromPath = getFriendlyUrlFromPath;
function validateCourse(coursePath) {
    const courseExists = fs.existsSync(coursePath);
    const directory = getFriendlyUrlFromPath(coursePath);
    const filePath = `${path.join(coursePath, '../')}${directory}-pathway.json`;
    if (courseExists) {
        return validatePathwayJson(filePath);
    }
    else {
        return `ValidationError: ${coursePath} does not exist. Please enter the right path`;
    }
}
exports.validateCourse = validateCourse;
async function validateScenario(path) {
    path = path.trim();
    const scenarioExists = fs.existsSync(path);
    if (scenarioExists) {
        return await validateIndexJson(path);
    }
    else {
        return `ValidationError: ${path} does not exist. Please enter the right path`;
    }
}
exports.validateScenario = validateScenario;
async function validateAllScenarios(path, ignore) {
    path = path.trim();
    var completeValidation = new CompleteValidation();
    //Path validation
    if (!fs.existsSync(path)) {
        var scenarioValidation = new ScenarioValidation(false, chalk.red('>> ') + 'Validation Error: The path is not correct. Please enter a valid path.');
        completeValidation.addValidation(scenarioValidation);
        return completeValidation;
    }
    if (fs.existsSync(path + '/index.json')) {
        var scenarioValidation = new ScenarioValidation(false, chalk.red('>> ') + 'ValidationError: It seams that you enter a specific scenario directory. Move one level up to validate all scenarios');
        completeValidation.addValidation(scenarioValidation);
        return completeValidation;
    }
    var scenarios = courses_1.getAllScenarios(path, ignore);
    if (scenarios === undefined || scenarios.length === 0) {
        var scenarioValidation = new ScenarioValidation(false, chalk.red('>> ') + 'ValidationError: There are no scenarios in the directory that you specified');
        completeValidation.addValidation(scenarioValidation);
        return completeValidation;
    }
    //Scenarios validations
    if (scenarios) {
        var i;
        for (i = 0; i < scenarios.length; i++) {
            var scenarioPath = getScenarioFullPath(scenarios[i]);
            var validations = await getScenarioValidations(scenarioPath);
            completeValidation.addValidation(validations);
        }
    }
    return completeValidation;
}
exports.validateAllScenarios = validateAllScenarios;
function getScenarioFullPath(path) {
    const splitPath = path.split('index.json');
    const directory = splitPath[0];
    return directory;
}
async function getScenarioValidations(scenario) {
    var validation = await validateIndexJson(scenario);
    var scenarioValidation;
    var message = chalk.gray('Scenario=' + scenario + ' - ');
    if (validation === true) {
        message = message + chalk.green('is valid' + '\n');
        scenarioValidation = new ScenarioValidation(true, message);
    }
    else {
        message = message + chalk.red(validation + '\n');
        scenarioValidation = new ScenarioValidation(false, message);
    }
    return scenarioValidation;
}
function validateStep(steps, responses, path) {
    const scenarioPath = responses.scenarioPath || path;
    const scenarioDetails = file_utils_2.getScenarioIndex(scenarioPath);
    const existingSteps = file_utils_2.getScenarioSteps(scenarioDetails);
    const stepsToBeDeleted = steps.split(',').map(step => {
        return existingSteps.find(existingStep => step.toLowerCase().trim() === existingStep.title.toLowerCase());
    });
    return stepsToBeDeleted.includes(undefined)
        ? `Validation Error: One or more steps entered does not exist, Please enter the correct step name(s).`
        : true;
}
exports.validateStep = validateStep;
function validateAsset(path, response) {
    const fileExists = fs.existsSync(path);
    if (fileExists) {
        const stats = fs.statSync(path);
        if (stats.isDirectory()) {
            return 'Validation Error: Asset should be a file and not a directory';
        }
        return stats.size > 1000000
            ? 'Validation Error: File size should not be above 1mb(one mega byte)'
            : true;
    }
    else {
        return 'Validation Error: This file does not exist, please check that you entered the path correctly';
    }
}
exports.validateAsset = validateAsset;
function validatePathwayJson(pathwayFile) {
    const content = file_utils_1.getFileContents(pathwayFile);
    if (!fs.existsSync(pathwayFile)) {
        return 'Validation Error: Course has no pathway.json file.';
    }
    if (!content) {
        return 'Validation Error: pathway.json file cannot be empty.';
    }
    if (!content.title) {
        return 'Validation Error: Course has no title';
    }
    return true;
}
function validateTrainingPath(trainingPath) {
    if (!fs.existsSync(trainingPath)) {
        return 'Validation Error: The training path is not correct. Please enter a valid path.';
    }
    const stats = fs.statSync(trainingPath);
    if (!stats.isFile()) {
        return 'The training path should point to *-pathway.json, not a directory.';
    }
    var isValid;
    try {
        isValid = file_utils_1.validateJSON(trainingPath);
    }
    catch (error) {
        isValid = false;
    }
    if (!isValid) {
        return 'Validation Error: is not a valid JSON file.';
    }
    const content = file_utils_1.getFileContents(trainingPath);
    if (!content) {
        return 'Validation Error: pathway.json file cannot be empty.';
    }
    if (!content.title) {
        return 'Validation Error: Training has no title.';
    }
    return true;
}
exports.validateTrainingPath = validateTrainingPath;
function validateUsername(username) {
    return validateInput(username);
}
exports.validateUsername = validateUsername;
function validateCourseId(courseId) {
    return validateInput(courseId);
}
exports.validateCourseId = validateCourseId;
function validateTrainingId(trainingId) {
    return validateInput(trainingId);
}
exports.validateTrainingId = validateTrainingId;
function validateRepoPath(repoPath) {
    repoPath = file_utils_2.expandPath(repoPath);
    if (!fs.existsSync(repoPath)) {
        return 'Validation Error: The path specified not exist.';
    }
    var courseFilesPath = file_utils_2.listFiles(repoPath, 'pathway.json', ['training'], null, null);
    var scenarios = file_utils_1.getListScenariosDefinitions(repoPath);
    if ((!courseFilesPath || courseFilesPath.length === 0) && (!scenarios || scenarios.length === 0)) {
        return 'Validation Error: There are no courses or scenarios in the repo that you specified.';
    }
    return true;
}
exports.validateRepoPath = validateRepoPath;
